(ns primes.prime
  (:require [primes.util :refer [square-root]]))

(defn- generate-range
  "generates range used by Sieve of Eratosthenes.
  more information here -
https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"
  [limit n]
  (range (* n n) limit n))

;;algorithm is based on Sieve of Eratosthenes
(defn- generate-sieve
  "returns sieve for generating prime numbers between BOTTOM
  and UPPER. this can be given an EXISTING sieve created from
  numbers between 2 and BOTTOM if BOTTOM is greater
  than 2 from `generate-old-sieve`."
  ([upper]
   (generate-sieve 2 upper '()))
  ([bottom upper existing]
   (let [bottom-sqrt (square-root bottom)
         upper-sqrt (square-root upper)]
     (->> (inc upper-sqrt)
          (range (max 2 bottom-sqrt))
          (mapcat (partial generate-range upper))
          (concat existing)
          (apply hash-set)))))

(defn- round-to-start
  "calculates the value the sieve generation
  starts back up with in `generate-missing-sieve`.

  the sieve generated by I contains numbers
  of the form i^2 + x*i, where x is an integer.
  this calculates the closest number of that form
  to m, greater than or equal to M. thus allowing
  sieve generation to pick up where it left off."
  [m i]
  (letfn [(solve-for-x [m i]
            (int (Math/ceil (/ (- m (* i i)) i))))
          (plug-in-x [x i] (* (+ x i) i))]
    (plug-in-x (solve-for-x m i) i)))

(defn- generate-missing-sieve
  "returns sieve for numbers generated by numbers
between 2 and sqrt(BOTTOM) from BOTTOM to UPPER,
meaning the sieve only contains values between
BOTTOM and UPPER.

this is used to fill in the missing numbers
when increasing the range of sieve. this means
we don't have to recreate the entire sieve for numbers
between 2 and BOTTOM."
  [bottom upper]
  (let [missing-range (range 2 (inc (square-root bottom)))
        starts (map (partial round-to-start bottom)
                    missing-range)]
    (mapcat #(range %1 %2 %3)
            starts (repeat upper) missing-range)))

(defn- generate-primes-internal
  "internal function used to generate primes.

  BOTTOM is the beginning of the range, TOP is the end,
  and REMOVALS is the sieve generated for numbers up to TOP."
  [bottom top removals]
  (remove #(contains? removals %) (range 2 top)))

(defn generate-primes
  "calculates primes less than TOP by generating the sieve
  up to TOP and removing all numbers present in the sieve."
  [top]
  (generate-primes-internal 2 top (generate-sieve top)))

(defn generate-n-primes
  "generates N prime numbers."
  [n]
  (cond
    (< n 1) '()
    (= n 1) '(2)
    :else
    (let [log (Math/log n)
          estimate (int (* n (+ log (Math/log log))))]
      (loop [bottom 2
             upper estimate
             old '()]
        (let [older (generate-missing-sieve bottom upper)
              removals (generate-sieve bottom upper (concat old older))
              primes (generate-primes-internal bottom upper removals)]
          (if (>= (count primes) n)
            (take n primes)
            (recur upper (* 2 (inc upper)) removals)))))))
