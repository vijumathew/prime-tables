(ns prime-tables.prime
  (:require [prime-tables.util :refer [square-root]]))

(defn- generate-range
  "generates range used by Sieve of Eratosthenes.
  more information in the README."
  [limit n]
  (range (* n n) limit n))

(defn- generate-sieve
  "returns sieve for generating prime numbers between BOTTOM
  and UPPER. this can be given an EXISTING sieve created from
  numbers between 2 and BOTTOM if BOTTOM is greater
  than 2 from `generate-missing-sieve`."
  ([upper]
   (generate-sieve 2 upper '()))
  ([bottom upper existing-sieve]
   (let [bottom-sqrt (square-root bottom)
         upper-sqrt (square-root upper)]
     (->> (inc upper-sqrt)
          (range (max 2 bottom-sqrt))
          (mapcat (partial generate-range upper))
          (concat existing-sieve)
          (apply hash-set)))))

(defn- round-to-start
  "calculates the value the sieve generation
  starts back up with in `generate-missing-sieve`.

  the sieve generated by I contains numbers
  of the form i^2 + x*i, where x is an integer.
  this calculates the closest number of that form
  to m, greater than or equal to M. thus allowing
  sieve generation to pick up where it left off."
  [m i]
  (letfn [(solve-for-x [m i]
            (int (Math/ceil (/ (- m (* i i)) i))))
          (plug-in-x [x i] (* (+ x i) i))]
    (plug-in-x (solve-for-x m i) i)))

(defn- generate-missing-sieve
  "returns sieve for numbers generated by numbers
between 2 and sqrt(BOTTOM) from BOTTOM to UPPER,
meaning the sieve only contains values between
BOTTOM and UPPER.

this is used to fill in the missing numbers
when increasing the range of sieve. this means
we don't have to recreate the entire sieve for numbers
between 2 and BOTTOM."
  [bottom upper]
  (let [missing-range (range 2 (inc (square-root bottom)))
        starts (map (partial round-to-start bottom)
                    missing-range)]
    (mapcat #(range %1 %2 %3)
            starts (repeat upper) missing-range)))

(defn- generate-primes-internal
  "internal function used to generate primes up to TOP.
  SIEVE is the sieve generated for numbers up to TOP."
  [top sieve]
  (remove #(contains? sieve %) (range 2 top)))

(defn generate-primes
  "calculates primes less than TOP by generating the sieve
  up to TOP and removing all numbers present in the sieve."
  [top]
  (generate-primes-internal top (generate-sieve top)))

(defn generate-n-primes
  "generates N prime numbers."
  [n]
  (cond
    (< n 1) '()
    (= n 1) '(2)
    :else
    (let [log (Math/log n)
          estimate (int (* n (+ log (Math/log log))))]
      (loop [bottom 2
             upper estimate
             existing-sieve '()]
        (let [missing-sieve (generate-missing-sieve bottom upper)
              sieve (generate-sieve bottom upper (concat existing-sieve missing-sieve))
              primes (generate-primes-internal upper sieve)]
          (if (>= (count primes) n)
            (take n primes)
            (recur upper (* 2 (inc upper)) sieve)))))))
